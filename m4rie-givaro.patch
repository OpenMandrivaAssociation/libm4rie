--- ./src/permutation.h.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./src/permutation.h	2012-04-25 15:19:05.630000524 -0600
@@ -103,7 +103,7 @@ static inline void mzed_apply_p_right_tr
  */
 
 static inline void mzd_slice_apply_p_left(mzd_slice_t *A, mzp_t const *P) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_apply_p_left(A->x[i], P);
   }
 }
@@ -118,7 +118,7 @@ static inline void mzd_slice_apply_p_lef
  */
 
 static inline void mzd_slice_apply_p_left_trans(mzd_slice_t *A, mzp_t const *P) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_apply_p_left_trans(A->x[i], P);
   }
 }
@@ -133,7 +133,7 @@ static inline void mzd_slice_apply_p_lef
  */
 
 static inline void mzd_slice_apply_p_right(mzd_slice_t *A, mzp_t const *P) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_apply_p_right(A->x[i], P);
   }
 }
@@ -148,7 +148,7 @@ static inline void mzd_slice_apply_p_rig
  */
 
 static inline void mzd_slice_apply_p_right_trans(mzd_slice_t *A, mzp_t const *P) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_apply_p_right_trans(A->x[i], P);
   }
 }
@@ -165,7 +165,7 @@ static inline void mzd_slice_apply_p_rig
  */
 
 static inline void mzd_slice_apply_p_right_trans_tri(mzd_slice_t *A, mzp_t const *P) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_apply_p_right_trans_tri(A->x[i], P);
   }
 }
--- ./src/mzd_slice.h.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./src/mzd_slice.h	2012-04-25 15:18:00.759000842 -0600
@@ -89,7 +89,7 @@ static inline mzd_slice_t *mzd_slice_ini
   A->ncols = n;
   A->depth = ff->degree;
 
-  for(int i=0; i<A->depth; i++)
+  for(unsigned int i=0; i<A->depth; i++)
     A->x[i] = mzd_init(m,n);
   return A;
 }
@@ -149,7 +149,7 @@ static inline mzd_slice_t *_mzd_slice_ad
  */
 
 static inline void mzd_slice_free(mzd_slice_t *A) {
-  for(int i=0; i<A->depth; i++)
+  for(unsigned int i=0; i<A->depth; i++)
    mzd_free(A->x[i]);
 #if __M4RI_USE_MM_MALLOC
   _mm_free(A);
@@ -180,7 +180,7 @@ static inline mzd_slice_t *mzd_slice_con
   if(C == NULL)
     C = mzd_slice_init(A->finite_field, A->nrows, A->ncols + B->ncols);
 
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_concat(C->x[i], A->x[i], B->x[i]);
   }
   return C;
@@ -207,7 +207,7 @@ static inline mzd_slice_t *mzd_slice_sta
   if(C == NULL)
     C = mzd_slice_init(A->finite_field, A->nrows + B->nrows, A->ncols);
 
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_stack(C->x[i], A->x[i], B->x[i]);
   }
   return C;
@@ -231,7 +231,7 @@ static inline mzd_slice_t *mzd_slice_sub
   if(S==NULL)
     S = mzd_slice_init(A->finite_field, highr - lowr, highc - lowc);
 
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_submatrix(S->x[i], A->x[i], lowr, lowc, highr, highc);
   }
   return S;
@@ -267,7 +267,7 @@ static inline mzd_slice_t *mzd_slice_ini
   B->depth = A->depth;
   B->nrows = highr - lowr;
   B->ncols = highc - lowc;
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     B->x[i] = mzd_init_window(A->x[i], lowr, lowc, highr, highc);
   }
   return B;
@@ -282,7 +282,7 @@ static inline mzd_slice_t *mzd_slice_ini
  */
 
 static inline void mzd_slice_free_window(mzd_slice_t *A) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_free_window(A->x[i]);
   }
   m4ri_mm_free(A);
@@ -674,7 +674,7 @@ static inline mzd_slice_t *mzd_slice_cop
   if(B == NULL)
     B = mzd_slice_init(A->finite_field, A->nrows, A->ncols);
 
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_copy(B->x[i],A->x[i]);
   }
   return B;
@@ -694,7 +694,7 @@ static inline mzd_slice_t *mzd_slice_cop
 
 static inline word mzd_slice_read_elem(const mzd_slice_t *A, const rci_t row, const rci_t col) {
   word ret = 0;
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     ret |= mzd_read_bit(A->x[i], row, col)<<i;
   }
   return ret;
@@ -714,7 +714,7 @@ static inline word mzd_slice_read_elem(c
  */
 
 static inline void mzd_slice_add_elem(mzd_slice_t *A, const rci_t row, const rci_t col, word elem) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     __mzd_xor_bits(A->x[i], row, col, 1, elem&1);
     elem=elem>>1;
   }
@@ -734,7 +734,7 @@ static inline void mzd_slice_add_elem(mz
  */
 
 static inline void mzd_slice_write_elem(mzd_slice_t *A, const rci_t row, const rci_t col, word elem) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_write_bit(A->x[i], row, col, elem&1);
     elem=elem>>1;
   }
@@ -757,7 +757,7 @@ static inline int mzd_slice_cmp(mzd_slic
   int r = 0;
   if ((A->finite_field != B->finite_field) | (A->depth != B->depth) )
     return -1;
-  for(int i=0; i<A->depth; i++)
+  for(unsigned int i=0; i<A->depth; i++)
     r |= mzd_cmp(A->x[i],B->x[i]);
   return r;
 }
@@ -771,7 +771,7 @@ static inline int mzd_slice_cmp(mzd_slic
  */
 
 static inline int mzd_slice_is_zero(const mzd_slice_t *A) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     if (!mzd_is_zero(A->x[i]))
       return 0;
   }
@@ -789,7 +789,7 @@ static inline int mzd_slice_is_zero(cons
  */
 
 static inline void mzd_slice_row_swap(mzd_slice_t *A, const rci_t rowa, const rci_t rowb) {
-  for(int i=0; i<A->depth; i++) {
+  for(unsigned int i=0; i<A->depth; i++) {
     mzd_row_swap(A->x[i], rowa, rowb);
   }
 }
@@ -809,7 +809,7 @@ static inline void mzd_slice_row_swap(mz
  */
 
 static inline void mzd_slice_copy_row(mzd_slice_t* B, size_t i, const mzd_slice_t* A, size_t j) {
-  for(int ii=0; ii<A->depth; ii++)
+  for(unsigned int ii=0; ii<A->depth; ii++)
     mzd_copy_row(B->x[ii], i, A->x[ii], j);
 }
 
@@ -824,7 +824,7 @@ static inline void mzd_slice_copy_row(mz
  */
 
 static inline void mzd_slice_col_swap(mzd_slice_t *A, const rci_t cola, const rci_t colb) {
-  for(int i=0; i<A->depth; i++)
+  for(unsigned int i=0; i<A->depth; i++)
     mzd_col_swap(A->x[i], cola, colb);
 }
 
@@ -858,7 +858,7 @@ static inline void mzd_slice_col_swap_in
  */
 
 static inline void mzd_slice_row_add(mzd_slice_t *A, const rci_t sourcerow, const rci_t destrow) {
-  for(int i=0; i<A->depth; i++)
+  for(unsigned int i=0; i<A->depth; i++)
     mzd_row_add(A->x[i], sourcerow, destrow);
 }
 
@@ -873,7 +873,7 @@ static inline void mzd_slice_row_add(mzd
  */
 
 static inline void mzd_slice_row_clear_offset(mzd_slice_t *A, const rci_t row, const rci_t coloffset) {
-  for(int i=0; i<A->depth; i++)
+  for(unsigned int i=0; i<A->depth; i++)
     mzd_row_clear_offset(A->x[i], row, coloffset);
 }
 
--- ./src/mzd_poly.h.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./src/mzd_poly.h	2012-04-25 15:15:50.508000002 -0600
@@ -48,7 +48,7 @@ static inline void _poly_add(mzd_t **c,
   case  0:
     break;
   default:
-    for(int i=0; i<length; i++)
+    for(unsigned int i=0; i<length; i++)
       mzd_add(c[ i], a[ i], b[ i]);
   }
 }
--- ./tests/testing.h.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./tests/testing.h	2012-04-25 15:19:36.133999969 -0600
@@ -120,7 +120,7 @@ static inline void mzd_slice_clear_canar
   const word mask_end   = __M4RI_LEFT_BITMASK((A->x[0]->offset + A->ncols)%m4ri_radix);
   const rci_t n = A->x[0]->width-1;
 
-  for(int e=0; e<A->finite_field->degree; e++) {
+  for(unsigned int e=0; e<A->finite_field->degree; e++) {
     for(rci_t i=0; i<A->nrows; i++) {
       A->x[e]->rows[i][0] &=mask_begin;
       A->x[e]->rows[i][n] &=mask_end;
@@ -142,9 +142,9 @@ static inline int mzd_slice_canary_is_al
         return 0;
       }
     }
-    return 1;
   }
-};
+  return 1;
+}
 
 static inline mzed_t *random_mzed_t(gf2e *ff, int m, int n) {
   mzed_t *A  = mzed_init(ff,m,n);
--- ./tests/test_elimination.cc.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./tests/test_elimination.cc	2012-04-25 15:15:50.513000003 -0600
@@ -1,3 +1,4 @@
+#define __STDC_LIMIT_MACROS
 #include "testing.h"
 #include <gf2e_cxx/finite_field_givaro.h>
 
@@ -77,7 +78,7 @@ int main(int argc, char **argv) {
   int fail_ret = 0;
 
   for(int k=2; k<=10; k++) {
-    GFqDom<int> GF = GFqDom<int>(2,k);
+    Givaro::GFqDom<int> GF = Givaro::GFqDom<int>(2,k);
     FiniteField *F = (FiniteField*)&GF;
     ff[k] = gf2e_init_givgfq(F);
   }
--- ./tests/test_ple.cc.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./tests/test_ple.cc	2012-04-25 15:15:50.516000003 -0600
@@ -1,3 +1,4 @@
+#define __STDC_LIMIT_MACROS
 #include "testing.h"
 #include <gf2e_cxx/finite_field_givaro.h>
 
@@ -188,7 +189,7 @@ int main(int argc, char **argv) {
   int fail_ret = 0;
 
   for(int k=2; k<=10; k++) {
-    GFqDom<int> GF = GFqDom<int>(2,k);
+    Givaro::GFqDom<int> GF = Givaro::GFqDom<int>(2,k);
     FiniteField *F = (FiniteField*)&GF;
     ff[k] = gf2e_init_givgfq(F);
   }
--- ./tests/test_multiplication.cc.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./tests/test_multiplication.cc	2012-04-25 15:15:50.518000003 -0600
@@ -25,6 +25,7 @@
 ******************************************************************************/
 
 
+#define __STDC_LIMIT_MACROS
 #include "testing.h"
 #include <gf2e_cxx/finite_field_givaro.h>
 
@@ -225,7 +226,7 @@ int main(int argc, char **argv) {
   int fail_ret = 0;
 
   for(int k=2; k<=10; k++) {
-    GFqDom<int> GF = GFqDom<int>(2,k);
+    Givaro::GFqDom<int> GF = Givaro::GFqDom<int>(2,k);
     FiniteField *F = (FiniteField*)&GF;
     ff[k] = gf2e_init_givgfq(F);
   }
--- ./tests/test_trsm.cc.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./tests/test_trsm.cc	2012-04-25 15:15:50.520000003 -0600
@@ -24,6 +24,7 @@
 *                  http://www.gnu.org/licenses/
 ******************************************************************************/
 
+#define __STDC_LIMIT_MACROS
 #include "testing.h"
 #include <gf2e_cxx/finite_field_givaro.h>
 
@@ -476,7 +477,7 @@ int main(int argc, char **argv) {
   int fail_ret = 0;
 
   for(int k=2; k<=10; k++) {
-    GFqDom<int> GF = GFqDom<int>(2,k);
+    Givaro::GFqDom<int> GF = Givaro::GFqDom<int>(2,k);
     FiniteField *F = (FiniteField*)&GF;
     ff[k] = gf2e_init_givgfq(F);
   }
--- ./tests/test_smallops.cc.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./tests/test_smallops.cc	2012-04-25 15:15:50.522000003 -0600
@@ -1,3 +1,4 @@
+#define __STDC_LIMIT_MACROS
 #include "testing.h"
 
 #include <gf2e_cxx/finite_field_givaro.h>
@@ -45,11 +46,11 @@ int test_slice_known_answers(gf2e *ff, i
   mzd_t *one = mzd_init(m,n);
   mzd_set_ui(one, 1);
 
-  for(int j=0; j<ff->degree; j++) {
+  for(unsigned int j=0; j<ff->degree; j++) {
     mzed_set_ui(A, 1<<j);
     mzd_slice_t *a = mzed_slice(NULL, A);
 
-    for(int i=0; i<a->depth; i++) {
+    for(unsigned int i=0; i<(unsigned int)a->depth; i++) {
       if (i!=j) {
         m4rie_check( mzd_is_zero(a->x[i]) );
       } else {
@@ -161,7 +162,7 @@ int main(int argc, char **argv) {
   int fail_ret = 0;
 
   for(int k=2; k<=10; k++) {
-    GFqDom<int> GF = GFqDom<int>(2,k);
+    Givaro::GFqDom<int> GF = Givaro::GFqDom<int>(2,k);
     FiniteField *F = (FiniteField*)&GF;
     ff[k] = gf2e_init_givgfq(F);
   }
--- ./gf2e_cxx/finite_field_givaro.h.orig	2012-04-14 07:58:21.000000000 -0600
+++ ./gf2e_cxx/finite_field_givaro.h	2012-04-25 15:15:50.524000003 -0600
@@ -22,7 +22,7 @@
 
 namespace M4RIE {
 
-  class FiniteField: public GFqDom<int> {
+  class FiniteField: public Givaro::GFqDom<int> {
   public: 
     unsigned int  log2pol(int x) { return _log2pol[x]; };
     unsigned int  pol2log(int x) { return _pol2log[x]; };
